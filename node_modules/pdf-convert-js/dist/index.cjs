'use strict';

var node_url = require('node:url');
var promises = require('node:fs/promises');
var node_fs = require('node:fs');
var childProcessPromise = require('child-process-promise');
var tmp = require('tmp-promise');
var axios = require('axios');

class PdfConvert {
    constructor(source, options) {
        this.source = source;
        this.options = {
            ghostscriptPath: new node_url.URL('./executables/ghostscript', (typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (document.currentScript && document.currentScript.src || new URL('index.cjs', document.baseURI).href))).pathname.replace(/^\//, ''),
            ...options,
        };
        if (process.platform === 'win32') {
            const suffix = ';' + this.options.ghostscriptPath;
            const key = process.env.Path ? 'Path' : 'PATH';
            if (!new RegExp(suffix.replace('/', '\\/')).test(process.env[key] || '')) {
                process.env[key] += suffix;
            }
        }
    }
    async convertPageToImage(page, options) {
        await this.writePDFToTemp();
        if (!this.tmpFile) {
            throw new Error('No temporary pdf file!');
        }
        try {
            const tmpImage = await tmp.file();
            await childProcessPromise.execFile('gs', [
                '-dQUIET',
                '-dPARANOIDSAFER',
                '-dBATCH',
                '-dNOPAUSE',
                '-dNOPROMPT',
                '-sDEVICE=png16m',
                '-dTextAlphaBits=4',
                '-dGraphicsAlphaBits=4',
                `-r${options?.resolution ?? 600}`,
                `-dFirstPage=${page}`,
                `-dLastPage=${page}`,
                `-sOutputFile=${tmpImage.path}`,
                this.tmpFile.path,
            ]);
            const buffer = await promises.readFile(tmpImage.path);
            await tmpImage.cleanup();
            return buffer;
        }
        catch (err) {
            throw new Error('Unable to process image from page: ' + err);
        }
    }
    async shrink(options) {
        await this.writePDFToTemp();
        if (!this.tmpFile) {
            throw new Error('No temporary pdf file!');
        }
        const dpi = options?.resolution ?? 300;
        const pdfVersion = options?.pdfVersion ?? (await this.getPdfVersion());
        const greyScale = options?.greyScale ?? false;
        let greyParams = [];
        if (greyScale) {
            greyParams = [
                '-sProcessColorModel=DeviceGray',
                '-sColorConversionStrategy=Gray',
                '-dOverrideICC',
            ];
        }
        try {
            const shrunkenFile = await tmp.file();
            await childProcessPromise.execFile('gs', [
                '-dQUIET',
                '-dPARANOIDSAFER',
                '-dBATCH',
                '-dNOPAUSE',
                '-dNOPROMPT',
                '-sDEVICE=pdfwrite',
                `-dCompatibilityLevel=${pdfVersion}`,
                '-dPDFSETTINGS=/screen',
                '-dEmbedAllFonts=true',
                '-dSubsetFonts=true',
                '-dAutoRotatePages=/None',
                '-dColorImageDownsampleType=/Bicubic',
                `-dColorImageResolution=${dpi}`,
                '-dGrayImageDownsampleType=/Bicubic',
                `-dGrayImageResolution=${dpi}`,
                '-dMonoImageDownsampleType=/Subsample',
                `-dMonoImageResolution=${dpi}`,
                '-dMonoImageDownsampleType=/Subsample',
                `-dMonoImageResolution=${dpi}`,
                ...greyParams,
                `-sOutputFile=${shrunkenFile.path}`,
                this.tmpFile.path,
            ]);
            const previousFileSize = this.getFileSizeInBytes(this.tmpFile.path);
            const shrunkenFileSize = this.getFileSizeInBytes(shrunkenFile.path);
            if (previousFileSize <= shrunkenFileSize) {
                const buffer = await promises.readFile(this.tmpFile.path);
                await shrunkenFile.cleanup();
                return buffer;
            }
            const buffer = await promises.readFile(shrunkenFile.path);
            await shrunkenFile.cleanup();
            return buffer;
        }
        catch (err) {
            throw new Error('Unable to process image from page: ' + err);
        }
    }
    getFileSizeInBytes(filename) {
        const stats = node_fs.statSync(filename, { bigint: true });
        return stats.size;
    }
    async getPdfVersion() {
        try {
            await this.writePDFToTemp();
            if (!this.tmpFile) {
                throw new Error('No temporary pdf file!');
            }
            let firstChunk = '';
            const stream = node_fs.createReadStream(this.tmpFile.path, {
                encoding: 'utf8',
                start: 0,
                end: 1024,
            });
            for await (const chunk of stream) {
                firstChunk = chunk;
                break;
            }
            await stream.close();
            const regex = /%PDF-[0-9].[0-9]/g;
            const found = firstChunk.match(regex);
            if (found !== null && Array.isArray(found) && found.length > 0) {
                const pdfVersionData = found[0].split('-');
                if (pdfVersionData.length === 2) {
                    return pdfVersionData[1].trim();
                }
            }
            return '1.4';
        }
        catch (error) {
            throw new Error(`Failed to retrieve pdf version: ${error}`);
        }
    }
    async getPageCount() {
        await this.writePDFToTemp();
        if (!this.tmpFile) {
            throw new Error('No temporary pdf file!');
        }
        let pagesCount;
        try {
            const filename = this.tmpFile.path.replace(/\\/g, '/').trim();
            const command = `gs -dNODISPLAY -dNOSAFER -q -c '(${filename}) (r) file runpdfbegin pdfpagecount = quit'`;
            const { stdout } = await childProcessPromise.exec(command);
            pagesCount = this.tryParsePagesInt(stdout);
        }
        catch (err) {
            const pgCount = this.tryParsePagesInt(err.stdout);
            if (pgCount !== undefined) {
                pagesCount = pgCount;
            }
            else {
                throw new Error('Unable to get page count: ' + err);
            }
        }
        if (pagesCount !== undefined) {
            return pagesCount;
        }
        else {
            throw new Error('Unable to get page count: parsing error');
        }
    }
    tryParsePagesInt(stdout) {
        if (typeof stdout === 'string' && stdout.length > 0) {
            try {
                return parseInt(stdout.replace(/\D/g, ''));
            }
            catch (error) {
                console.error(error);
            }
        }
        return undefined;
    }
    async writePDFToTemp() {
        if (this.tmpFile)
            return;
        try {
            this.tmpFile = await tmp.file();
        }
        catch (err) {
            throw new Error(`Unable to open tmp file: ` + err);
        }
        if (typeof this.source === 'string') {
            if (/^https?:\/\//.test(this.source)) {
                try {
                    const response = await axios.get(this.source, {
                        responseType: 'stream',
                    });
                    const stream = node_fs.createWriteStream(this.tmpFile.path);
                    response.data.pipe(stream);
                    await new Promise((resolve, reject) => {
                        stream.on('finish', resolve);
                        stream.on('error', reject);
                    });
                }
                catch (err) {
                    throw new Error('Unable to fetch file from web location: ' + err);
                }
            }
            else {
                await promises.copyFile(this.source, this.tmpFile.path);
            }
        }
        else {
            try {
                await promises.writeFile(this.tmpFile.path, this.source);
            }
            catch (err) {
                throw new Error('Unable to write tmp file: ' + err);
            }
        }
    }
    async dispose() {
        if (this.tmpFile) {
            await this.tmpFile.cleanup();
            this.tmpFile = undefined;
        }
    }
}

exports.PdfConvert = PdfConvert;
//# sourceMappingURL=index.cjs.map
